[{"categories":["Games"],"content":"学习第二篇 ","date":"2022-02-22","objectID":"/planefire_2/:0:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"一、实现效果 ","date":"2022-02-22","objectID":"/planefire_2/:1:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"效果图 ","date":"2022-02-22","objectID":"/planefire_2/:1:1","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"功能列表 飞机定时无限发射 左右键控制飞机左右移动 随机生成怪物，怪物有不同 子弹射中怪物后，子弹和怪物一起被摧毁 ","date":"2022-02-22","objectID":"/planefire_2/:1:2","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"二、知识点 ","date":"2022-02-22","objectID":"/planefire_2/:2:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"刚体 Dynamic 普通刚体 有质量 Static 静态刚体 质量无穷（地面） Kinematic 运动学刚体 质量为0（物理规律不起作用，一般用于碰撞检测） 设置刚体：Physics 2D -\u003eRigidBody 2D -\u003e Body Type -\u003e Dynamic/Static/Kinematic ","date":"2022-02-22","objectID":"/planefire_2/:2:1","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"碰撞体 Physics 2D -\u003e Box/Circle Collider 2D -\u003e is Trigger ","date":"2022-02-22","objectID":"/planefire_2/:2:2","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"碰撞检测 设置可碰撞：添加碰撞组件Physics 2D -\u003eBox Collider2D-\u003eis Trigger 打勾 添加碰撞检测函数(例)： private void OnTriggerEnter2D(Collider2D collision){Debug.Log(\"检测到了碰撞\");} Collider2D collision表示对方的碰撞组件 collision.gameObject——对方 collision.name——对方节点名称 collision.tag —— 对方的节点的Tag collision.transform——对方的Transform组件 碰撞事件回调： 1、OnTriggerEnter2D,两碰撞体开始相遇 2、OnTriggerStay2D,两碰撞体接触中 3、OnTriggerExit2D,两碰撞体离开 ","date":"2022-02-22","objectID":"/planefire_2/:2:3","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"随机数 value=Random.Range(min,max); eg:float x=Random.Range(-2,2); ","date":"2022-02-22","objectID":"/planefire_2/:2:4","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"定时器 InvokeRepeating(method, delay,interval);//delay 多长时间后执行第一次，interval 几秒钟重复一次方法调用 eg:InvokeRepeating(“CreatePig”,0.1f ,2f); ","date":"2022-02-22","objectID":"/planefire_2/:2:5","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"随机选择图片 int index = Random.Range(0, images.Length); SpriteRenderer renderer = monster.GetComponent(); renderer.sprite = this.images[index]; ","date":"2022-02-22","objectID":"/planefire_2/:2:6","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"三、代码实现 MyGame.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyGame : MonoBehaviour { // Start is called before the first frame update void Start() { Application.targetFrameRate = 60; } // Update is called once per frame void Update() { } } MyBullet.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyBullet : MonoBehaviour { public float speed = 2.0f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; transform.Translate(0, dy, 0, Space.Self); Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); if(sp.y\u003eScreen.height) { Destroy(this.gameObject); } } private void OnTriggerEnter2D(Collider2D collision) { if(collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); } } } MyJet.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyJet : MonoBehaviour { public float speed = 2.0f; public GameObject bulletPrefab; private float count = 0; private float interval = 0.4f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { count += Time.deltaTime; if(count \u003einterval ) { count = 0; Fire(); } float step = speed * Time.deltaTime; if(Input.GetKey(KeyCode.LeftArrow)) { transform.Translate(-step, 0, 0); } if (Input.GetKey(KeyCode.RightArrow)) { transform.Translate(step, 0, 0); } } void Fire() { Vector3 pos = transform.position + new Vector3(0, 1, 0); GameObject bullet = Instantiate(bulletPrefab, pos, transform.rotation); } } Monster.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class Monster : MonoBehaviour { public float speed = 1.0f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; transform.Translate(0, -dy, 0, Space.Self); Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); if (-sp.y*2 \u003e Screen.height) { Destroy(this.gameObject); } } } MonsterCtrl.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MonsterCtrl : MonoBehaviour { public GameObject MonsterPrefab; public Sprite[] images; // Start is called before the first frame update void Start() { InvokeRepeating(\"CreateMonster\", 0.1f, 2f); } // Update is called once per frame void Update() { } void CreateMonster() { float x = Random.Range(-2, 2); float y = 5; GameObject monster = Instantiate(MonsterPrefab); monster.transform.position = new Vector3(x, y, 0); // int index = Random.Range(0, images.Length);//6张图片 SpriteRenderer renderer = monster.GetComponent\u003cSpriteRenderer\u003e(); renderer.sprite = this.images[index]; } } ","date":"2022-02-22","objectID":"/planefire_2/:3:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"四、遇到了一个非常头疼的问题 报错: The object of type ‘xxx’ has been destroyed but you are still trying to access it 但我的逻辑明明没有错误，也是照着老师的步骤来的，怎么会在摧毁上一个预制体后不能成功创建下一个预制体呢？？？？？然后搜索了很多，怀疑是因为程序调用的时候虽然逻辑上预制体被摧毁了，但其实程序滞留，在创建预制体时访问的是上一个空的预制体，所以访问不了。woc，这啥呀这是，关键是人家老师为啥能行，我就不行，我电脑可是apple M1啊，按道理cpu速度也是行的啊😭😭😭 皆大欢喜！！！！👏👏👏😃😃😃解决了！！！ 我是sabi叭，完全是因为预制体移错了，贴图警告⚠️ 不知道为什么，当路径二的怪物变蓝后我就自认为它就变成预制体了，但其实并不是，只能从Prefab的文件夹中移出，也不能这样说，总的来说是要看准到底谁是预制体。 ","date":"2022-02-22","objectID":"/planefire_2/:4:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"学习第一篇 ","date":"2022-02-22","objectID":"/planefire_1/:0:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"一、效果图 大概的效果图如下，实现的功能：😁通过点击鼠标飞机会射出子弹，若子弹超出屏幕外会自动销毁。 ","date":"2022-02-22","objectID":"/planefire_1/:1:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"二、功能实现 ","date":"2022-02-22","objectID":"/planefire_1/:2:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"1、场景对象 【Main Camera】 代表主摄像机，需要这个我们才能看到如今这个视角 【游戏主控】 上面不挂载任何图片对象，但挂了一个c#文件，主要用来全局设置。比如这个项目所涉及到的时间针率。 3.【子弹】 这个子弹可惜忽略，主要是通过它来创建子弹预制体 4.【子弹Prefab】此对象需要挂MyBullet，特别提醒需要在【飞机】脚本下挂它 5.【飞机】 挂MyJet ","date":"2022-02-22","objectID":"/planefire_1/:3:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"2、代码实现 游戏主控—MyGame代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyGame : MonoBehaviour { // Start is called before the first frame update void Start() { //设置帧率为60 //Application:应用 //target:目标 //Frame:帧 //Rate:率 Application.targetFrameRate= 60; } // Update is called once per frame void Update() { } } 子弹Prefab—MyBullet代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyBullet : MonoBehaviour { //在inspector中会出现【speed】，并且可以自由设置参数 public float speed = 5.5f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //设置每刷新一次y轴的坐标，y轴坐标随时间增加，即表现为向上的运动 float dy = speed * Time.deltaTime; //将空间坐标翻译赋给transform transform.Translate(0, dy, 0, Space.Self); //创建对象（而这个对象的坐标由transform提供）表现形式由主摄像机的世界坐标表示 Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); //如果对象的y坐标超过屏幕的高度则被摧毁 if (sp.y \u003e Screen.height) { Destroy(this.gameObject); } } } 飞机—MyJet代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyJet : MonoBehaviour { public GameObject myPrefab; private float interval = 0.4f; private float count = 0; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //如果鼠标按下，就射出子弹 if(Input.GetMouseButtonDown(0)) { Fire(); } } private void Fire() { //创建预制体 //Instantiate：示例 GameObject bullet = Instantiate(myPrefab); //子弹的位置=飞机所在位置的y轴加1 bullet.transform.position = transform.position + new Vector3(0, 1f, 0); } } ","date":"2022-02-22","objectID":"/planefire_1/:4:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"三、总结 现在我只是刚开始，给自己打气遇到挫折难题不要放弃，踏踏实实学习，一定会在毕业前修炼成大师的！ 对的，这个游戏还没结束，下一章会继续写键盘控制飞机、子弹击中敌人，敌人消失。😊😊😊😊下一章见！ ","date":"2022-02-22","objectID":"/planefire_1/:5:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Algorithm"],"content":"给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array ","date":"2022-01-26","objectID":"/algorithm_day1/:0:0","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法一：暴力破解法 （idea：找到一个数与其后面的数比较，若最小则对调） （缺点：时间复杂度O（n^2），过于复杂，且没有利用题目原本数组的升序条件，没能通过） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { for(int i=0;i\u003cnums.size();i++) { nums[i]=nums[i]*nums[i]; } for(int j=0;j\u003cnums.size();j++) { for(int i=j+1;i\u003cnums.size();i++) { int trans; if(nums[i]\u003cnums[j]) { trans=nums[i]; nums[i]=nums[j]; nums[j]=trans; } } } return nums; } }; 结果： ","date":"2022-01-26","objectID":"/algorithm_day1/:0:1","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法二：暴力破解法 （这个是官方的暴力破解，运用了相应的函数，和我上面写的思路是一样的，只不过我没有用封装函数，但这种方法能过，时间复杂度为O（nlogn）） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e ans; for(int num:nums) { ans.push_back(num*num); } sort(ans.begin(),ans.end()); return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:2","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法三：双指针法 （如果我们使用两个指针分别指向位置0和位置n-1，每次比较选择更大的树逆序放于数组，就比如说位置0和位置n-1的数，因为题目条件，他们俩之间一定有一个最大的树可以放在新数组的最后面，依次类推） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { int n=nums.size(); vector\u003cint\u003e ans(n); for(int left=0,right=n-1,p=n-1;left\u003c=right;) { if(nums[left]*nums[left]\u003cnums[right]*nums[right]) { ans[p]=nums[right]*nums[right]; right--; } else { ans[p]=nums[left]*nums[left]; left++; } p--; } return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:3","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"}]