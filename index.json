[{"categories":["Algorithm"],"content":"给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array ","date":"2022-01-26","objectID":"/algorithm_day1/:0:0","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法一：暴力破解法： （idea：找到一个数与其后面的数比较，若最小则对调） （缺点：时间复杂度O（n^2），过于复杂，且没有利用题目原本数组的升序条件，没能通过） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { for(int i=0;i\u003cnums.size();i++) { nums[i]=nums[i]*nums[i]; } for(int j=0;j\u003cnums.size();j++) { for(int i=j+1;i\u003cnums.size();i++) { int trans; if(nums[i]\u003cnums[j]) { trans=nums[i]; nums[i]=nums[j]; nums[j]=trans; } } } return nums; } }; 结果： ","date":"2022-01-26","objectID":"/algorithm_day1/:0:1","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"暴力破解法 方法二： （这个是官方的暴力破解，运用了相应的函数，和我上面写的思路是一样的，只不过我没有用封装函数，但这种方法能过，时间复杂度为O（nlogn）） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e ans; for(int num:nums) { ans.push_back(num*num); } sort(ans.begin(),ans.end()); return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:2","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法三：双指针法 （如果我们使用两个指针分别指向位置0和位置n-1，每次比较选择更大的树逆序放于数组，就比如说位置0和位置n-1的数，因为题目条件，他们俩之间一定有一个最大的树可以放在新数组的最后面，依次类推） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { int n=nums.size(); vector\u003cint\u003e ans(n); for(int left=0,right=n-1,p=n-1;left\u003c=right;) { if(nums[left]*nums[left]\u003cnums[right]*nums[right]) { ans[p]=nums[right]*nums[right]; right--; } else { ans[p]=nums[left]*nums[left]; left++; } p--; } return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:3","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"}]