[{"categories":["Games"],"content":"「持续按键子弹间隔时间发射」「随机血条」「开始和结束界面」「在最后一个场景中得到前面场景对象的函数/值」「陨石坠落」 ","date":"2022-02-22","objectID":"/planefire_4/:0:0","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"一、实现效果 开始界面： 游戏界面： 结束界面 ","date":"2022-02-22","objectID":"/planefire_4/:1:0","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"二、关键技术实现 ","date":"2022-02-22","objectID":"/planefire_4/:2:0","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"1、 持续按键，但子弹不连续发射，而是间隔时间发射 主要思路是在按下按键时，设置一个定时器 public class MyJet : MonoBehaviour { public float deltaT = 0.5f;//设置一个你理想状态的子弹发射间隔时间 private float InvokeTime; // Start is called before the first frame update void Start() { InvokeTime = deltaT;//初始化 } // Update is called once per frame void Update() { if (Input.GetKey(KeyCode.Space)) { InvokeTime += Time.deltaTime;//检查到空格键一直按下的时候会不断累加 if(InvokeTime\u003edeltaT)//当累加到大于deltaT时便执行子弹发射 { Fire();//发射子弹的函数，可替换 InvokeTime = 0; } } if(Input.GetKeyUp(KeyCode.Space)) { InvokeTime = deltaT;//当空格键抬起时，将invokTime恢复原来值 } } } ","date":"2022-02-22","objectID":"/planefire_4/:2:1","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"2、设置一个随机血条，不同血条代表的分值不同，且当子弹击中怪物时，血条会逐减。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/24c7374decf843de840dac10babc11bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWnpf56iL5bqP5aqb,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center =200x250) 关键点1、找到/制作两个可重合的血条（白色背景，红色前景） 关键点2、将两个血条的中心轴定位在血条的==左边缘==（pivot=center Left） 关键点3、将两个血条与原本怪物形成父子关系，并整体制作为预制体 代码实现： public class Monster : MonoBehaviour { public float speed = 1.0f; public int value; // 价值 (1-5), 击杀此怪可以获得的加分 public int hp; // 血量, 初始值为value // hp/value节点 private Transform hpNode; private Transform game; // Start is called before the first frame update void Start() { // 节点名称 this.name = \"Monster\"; game = GameObject.Find(\"主控脚本\").transform; // 怪物的价值：1-5之间，随机指定 value = Random.Range(0, 5) + 1; hp = value; // 血条显示 hpNode = transform.Find(\"hp/value\"); SetHealth(hp); } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; transform.Translate(0, -dy, 0, Space.Self); Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); if (sp.y\u003c 0) { Destroy(this.gameObject); } } // 更新HP显示 public void SetHealth(int hpValue) { hpNode.localScale = new Vector3(hpValue / 5f, 1, 1);//x轴上的比例缩小，与中心轴点位置有关，所以一定要设置好图片的中心点轴位置靠左，这样比例缩小时才会是那种效果 } private void OnTriggerEnter2D(Collider2D collision) { if (collision.name.Equals(\"Bullet\")) { // 被子弹击中，HP-1 hp -= 1; Destroy(collision.gameObject); // 更新HP显示 SetHealth(hp); // HP降为0时，自动销毁此怪 if (hp \u003c= 0) { Destroy(this.gameObject); // 玩有得分 + this.value，这是传给在另外一个类的方法value的值。 game.SendMessage(\"AddScore\", this.value); } } } } ","date":"2022-02-22","objectID":"/planefire_4/:2:2","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"3、设置开始和结束界面 开始和结束的场景需要创建 设置场景顺序（Fire-\u003eBuildSetting-\u003e'+'） 分别在开始和结束的场景中加入canvas ==跳转函数==： UnityEngine.SceneManagement.SceneManager.LoadScene(0); //0代表场景顺序 ","date":"2022-02-22","objectID":"/planefire_4/:2:3","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"4、如何在最后一个场景中得到前面场景对象的函数/值 我们知道，如果场景切换到下一个场景后，之前的场景对象会被销毁 但是，若是我们想要得到前一个场景的值，需要保留上一个对象 ==永久保留对象的函数==： void Start() { DontDestroyOnLoad(this.gameObject); } ","date":"2022-02-22","objectID":"/planefire_4/:2:4","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"5、实现陨石坠落 方法和前面的方法雷同，使陨石成为一个刚体、碰撞体、预制体，且挂一个脚本控制它的飞行方向、飞行速度和销毁事件，若飞机与陨石相撞、游戏结束。 ","date":"2022-02-22","objectID":"/planefire_4/:2:5","tags":["C# ","Unity","PlaneFire"],"title":"PlaneFire_4","uri":"/planefire_4/"},{"categories":["Games"],"content":"学习第三章 ","date":"2022-02-22","objectID":"/planefire_3/:0:0","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"一、实现效果 ","date":"2022-02-22","objectID":"/planefire_3/:1:0","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"功能实现 背景图片连续不断向下平移 有背景音乐，并能通过点击星星✨来控制暂停/播放 子弹发射时会有音效 添加UI组件（image和text）实现击中目标时，得分加1 ","date":"2022-02-22","objectID":"/planefire_3/:1:1","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"二、知识点学习 ","date":"2022-02-22","objectID":"/planefire_3/:2:0","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"1、将图片设置为固定宽度（同比缩放） Sprite sprite = this.images[index]; float imageWidth = sprite.rect.width;//获取图像的实际宽度 float scale = 100 / imageWidth;//设置为100像素，缩放比例 monster.transform.localScale = new Vector3(scale, scale, scale); ","date":"2022-02-22","objectID":"/planefire_3/:2:1","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"2、音频播放 AudioSource:声音源 AudioListener:接收者 添加音频：在一个组件上添加Audio Source组件 音频的代码播放（常用API）： clip（选哪首）/mute（静音）/loop（循环）/volume（音量）/isPlaying Play() Stop() Pause() PlayOneShot(clip)//新开一个播放 延时调用API Invoke(“方法名称”,delay);//延时调用方法 CancelInvoke(“name”)//取消延时调用 isInvoking(“name”)//判断是否正在调用 InvokeRepeating(“name”, delay,interval)//延时重复调用 ","date":"2022-02-22","objectID":"/planefire_3/:2:2","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"3、 消息调用（传给其他类的方法的值） GameObject main=GameObject.Find(“游戏主控”); main.SendMessage(“AddScore”,1); ","date":"2022-02-22","objectID":"/planefire_3/:2:3","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"4、UI事件 我所理解的UI是浮于屏幕表面的按键，即与游戏画面不在同一个平面上 添加控件：添加UI-\u003eCanvas，右键点击canvas可添加text/image等不同属性UI控件 ","date":"2022-02-22","objectID":"/planefire_3/:2:4","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"三、代码实现 背景图片动态移动： public class BackgroundCtrl : MonoBehaviour { Transform bg1; Transform bg2; public float speed = 1.0f; // Start is called before the first frame update void Start() { bg1 = GameObject.Find(\"背景/bg1\").transform; bg2 = GameObject.Find(\"背景/bg2\").transform; bg1.position = new Vector3(0, 0, 0); bg2.position = new Vector3(0, 10, 0); } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; bg1.Translate(0, -dy, 0); bg2.Translate(0, -dy, 0); if(bg1.position.y\u003c-10) { bg1.position = new Vector3(0, 10, 0); } if (bg2.position.y \u003c -10) { bg2.position = new Vector3(0, 10, 0); } } } 背景音乐： void Update() { if(Input.GetMouseButtonDown(0)) { Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);//获取鼠标坐标 mousePos.z = 0; float distance = (mousePos - transform.position).magnitude;//计算星星坐标与鼠标的距离 if (distance \u003c 0.5) { AudioSource audio = GetComponent\u003cAudioSource\u003e();//获取音乐组件 if (audio.isPlaying) { audio.Pause(); } else { audio.Play(); } } } } 子弹音效 AudioSource audio = GetComponent\u003cAudioSource\u003e();//获取音乐组件 audio.PlayOneShot(audio.clip); UI和得分 public void AddScore(int value) { score += value; scoreText.text = \"得分:\" + score; Debug.Log(\"当前得分：\" + score); } GameObject Monster = GameObject.Find(\"主控脚本\"); Monster.SendMessage(\"AddScore\", 1); ","date":"2022-02-22","objectID":"/planefire_3/:3:0","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"四、心得 都学到这了，最有体会的一点就是unity实在是太强大太方便了哈哈哈，除了刚上手时有一些组件就会记不住，但是用顺手后还是非常方便的，还有学这个一定得做好文件管理，不要乱糟糟的，不然之后找文件的时候会头昏眼花。 ","date":"2022-02-22","objectID":"/planefire_3/:4:0","tags":[" C# ","Unity","PlaneFire"],"title":"PlaneFire_3","uri":"/planefire_3/"},{"categories":["Games"],"content":"学习第二篇 ","date":"2022-02-22","objectID":"/planefire_2/:0:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"一、实现效果 ","date":"2022-02-22","objectID":"/planefire_2/:1:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"效果图 ","date":"2022-02-22","objectID":"/planefire_2/:1:1","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"功能列表 飞机定时无限发射 左右键控制飞机左右移动 随机生成怪物，怪物有不同 子弹射中怪物后，子弹和怪物一起被摧毁 ","date":"2022-02-22","objectID":"/planefire_2/:1:2","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"二、知识点 ","date":"2022-02-22","objectID":"/planefire_2/:2:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"刚体 Dynamic 普通刚体 有质量 Static 静态刚体 质量无穷（地面） Kinematic 运动学刚体 质量为0（物理规律不起作用，一般用于碰撞检测） 设置刚体：Physics 2D -\u003eRigidBody 2D -\u003e Body Type -\u003e Dynamic/Static/Kinematic ","date":"2022-02-22","objectID":"/planefire_2/:2:1","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"碰撞体 Physics 2D -\u003e Box/Circle Collider 2D -\u003e is Trigger ","date":"2022-02-22","objectID":"/planefire_2/:2:2","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"碰撞检测 设置可碰撞：添加碰撞组件Physics 2D -\u003eBox Collider2D-\u003eis Trigger 打勾 添加碰撞检测函数(例)： private void OnTriggerEnter2D(Collider2D collision){Debug.Log(\"检测到了碰撞\");} Collider2D collision表示对方的碰撞组件 collision.gameObject——对方 collision.name——对方节点名称 collision.tag —— 对方的节点的Tag collision.transform——对方的Transform组件 碰撞事件回调： 1、OnTriggerEnter2D,两碰撞体开始相遇 2、OnTriggerStay2D,两碰撞体接触中 3、OnTriggerExit2D,两碰撞体离开 ","date":"2022-02-22","objectID":"/planefire_2/:2:3","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"随机数 value=Random.Range(min,max); eg:float x=Random.Range(-2,2); ","date":"2022-02-22","objectID":"/planefire_2/:2:4","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"定时器 InvokeRepeating(method, delay,interval);//delay 多长时间后执行第一次，interval 几秒钟重复一次方法调用 eg:InvokeRepeating(“CreatePig”,0.1f ,2f); ","date":"2022-02-22","objectID":"/planefire_2/:2:5","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"随机选择图片 int index = Random.Range(0, images.Length); SpriteRenderer renderer = monster.GetComponent(); renderer.sprite = this.images[index]; ","date":"2022-02-22","objectID":"/planefire_2/:2:6","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"三、代码实现 MyGame.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyGame : MonoBehaviour { // Start is called before the first frame update void Start() { Application.targetFrameRate = 60; } // Update is called once per frame void Update() { } } MyBullet.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyBullet : MonoBehaviour { public float speed = 2.0f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; transform.Translate(0, dy, 0, Space.Self); Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); if(sp.y\u003eScreen.height) { Destroy(this.gameObject); } } private void OnTriggerEnter2D(Collider2D collision) { if(collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); } } } MyJet.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyJet : MonoBehaviour { public float speed = 2.0f; public GameObject bulletPrefab; private float count = 0; private float interval = 0.4f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { count += Time.deltaTime; if(count \u003einterval ) { count = 0; Fire(); } float step = speed * Time.deltaTime; if(Input.GetKey(KeyCode.LeftArrow)) { transform.Translate(-step, 0, 0); } if (Input.GetKey(KeyCode.RightArrow)) { transform.Translate(step, 0, 0); } } void Fire() { Vector3 pos = transform.position + new Vector3(0, 1, 0); GameObject bullet = Instantiate(bulletPrefab, pos, transform.rotation); } } Monster.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class Monster : MonoBehaviour { public float speed = 1.0f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { float dy = speed * Time.deltaTime; transform.Translate(0, -dy, 0, Space.Self); Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); if (-sp.y*2 \u003e Screen.height) { Destroy(this.gameObject); } } } MonsterCtrl.cs using System.Collections; using System.Collections.Generic; using UnityEngine; public class MonsterCtrl : MonoBehaviour { public GameObject MonsterPrefab; public Sprite[] images; // Start is called before the first frame update void Start() { InvokeRepeating(\"CreateMonster\", 0.1f, 2f); } // Update is called once per frame void Update() { } void CreateMonster() { float x = Random.Range(-2, 2); float y = 5; GameObject monster = Instantiate(MonsterPrefab); monster.transform.position = new Vector3(x, y, 0); // int index = Random.Range(0, images.Length);//6张图片 SpriteRenderer renderer = monster.GetComponent\u003cSpriteRenderer\u003e(); renderer.sprite = this.images[index]; } } ","date":"2022-02-22","objectID":"/planefire_2/:3:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"四、遇到了一个非常头疼的问题 报错: The object of type ‘xxx’ has been destroyed but you are still trying to access it 但我的逻辑明明没有错误，也是照着老师的步骤来的，怎么会在摧毁上一个预制体后不能成功创建下一个预制体呢？？？？？然后搜索了很多，怀疑是因为程序调用的时候虽然逻辑上预制体被摧毁了，但其实程序滞留，在创建预制体时访问的是上一个空的预制体，所以访问不了。woc，这啥呀这是，关键是人家老师为啥能行，我就不行，我电脑可是apple M1啊，按道理cpu速度也是行的啊😭😭😭 皆大欢喜！！！！👏👏👏😃😃😃解决了！！！ 我是sabi叭，完全是因为预制体移错了，贴图警告⚠️ 不知道为什么，当路径二的怪物变蓝后我就自认为它就变成预制体了，但其实并不是，只能从Prefab的文件夹中移出，也不能这样说，总的来说是要看准到底谁是预制体。 ","date":"2022-02-22","objectID":"/planefire_2/:4:0","tags":["C#","Unity","PlaneFire"],"title":"PlaneFire_2","uri":"/planefire_2/"},{"categories":["Games"],"content":"学习第一篇 ","date":"2022-02-22","objectID":"/planefire_1/:0:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"一、效果图 大概的效果图如下，实现的功能：😁通过点击鼠标飞机会射出子弹，若子弹超出屏幕外会自动销毁。 ","date":"2022-02-22","objectID":"/planefire_1/:1:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"二、功能实现 ","date":"2022-02-22","objectID":"/planefire_1/:2:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"1、场景对象 【Main Camera】 代表主摄像机，需要这个我们才能看到如今这个视角 【游戏主控】 上面不挂载任何图片对象，但挂了一个c#文件，主要用来全局设置。比如这个项目所涉及到的时间针率。 3.【子弹】 这个子弹可惜忽略，主要是通过它来创建子弹预制体 4.【子弹Prefab】此对象需要挂MyBullet，特别提醒需要在【飞机】脚本下挂它 5.【飞机】 挂MyJet ","date":"2022-02-22","objectID":"/planefire_1/:3:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"2、代码实现 游戏主控—MyGame代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyGame : MonoBehaviour { // Start is called before the first frame update void Start() { //设置帧率为60 //Application:应用 //target:目标 //Frame:帧 //Rate:率 Application.targetFrameRate= 60; } // Update is called once per frame void Update() { } } 子弹Prefab—MyBullet代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyBullet : MonoBehaviour { //在inspector中会出现【speed】，并且可以自由设置参数 public float speed = 5.5f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //设置每刷新一次y轴的坐标，y轴坐标随时间增加，即表现为向上的运动 float dy = speed * Time.deltaTime; //将空间坐标翻译赋给transform transform.Translate(0, dy, 0, Space.Self); //创建对象（而这个对象的坐标由transform提供）表现形式由主摄像机的世界坐标表示 Vector3 sp = Camera.main.WorldToScreenPoint(transform.position); //如果对象的y坐标超过屏幕的高度则被摧毁 if (sp.y \u003e Screen.height) { Destroy(this.gameObject); } } } 飞机—MyJet代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class MyJet : MonoBehaviour { public GameObject myPrefab; private float interval = 0.4f; private float count = 0; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //如果鼠标按下，就射出子弹 if(Input.GetMouseButtonDown(0)) { Fire(); } } private void Fire() { //创建预制体 //Instantiate：示例 GameObject bullet = Instantiate(myPrefab); //子弹的位置=飞机所在位置的y轴加1 bullet.transform.position = transform.position + new Vector3(0, 1f, 0); } } ","date":"2022-02-22","objectID":"/planefire_1/:4:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Games"],"content":"三、总结 现在我只是刚开始，给自己打气遇到挫折难题不要放弃，踏踏实实学习，一定会在毕业前修炼成大师的！ 对的，这个游戏还没结束，下一章会继续写键盘控制飞机、子弹击中敌人，敌人消失。😊😊😊😊下一章见！ ","date":"2022-02-22","objectID":"/planefire_1/:5:0","tags":["c#","Unity","PlaneFire"],"title":"PlaneFire_1","uri":"/planefire_1/"},{"categories":["Algorithm"],"content":"给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array ","date":"2022-01-26","objectID":"/algorithm_day1/:0:0","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法一：暴力破解法 （idea：找到一个数与其后面的数比较，若最小则对调） （缺点：时间复杂度O（n^2），过于复杂，且没有利用题目原本数组的升序条件，没能通过） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { for(int i=0;i\u003cnums.size();i++) { nums[i]=nums[i]*nums[i]; } for(int j=0;j\u003cnums.size();j++) { for(int i=j+1;i\u003cnums.size();i++) { int trans; if(nums[i]\u003cnums[j]) { trans=nums[i]; nums[i]=nums[j]; nums[j]=trans; } } } return nums; } }; 结果： ","date":"2022-01-26","objectID":"/algorithm_day1/:0:1","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法二：暴力破解法 （这个是官方的暴力破解，运用了相应的函数，和我上面写的思路是一样的，只不过我没有用封装函数，但这种方法能过，时间复杂度为O（nlogn）） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e ans; for(int num:nums) { ans.push_back(num*num); } sort(ans.begin(),ans.end()); return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:2","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"},{"categories":["Algorithm"],"content":"方法三：双指针法 （如果我们使用两个指针分别指向位置0和位置n-1，每次比较选择更大的树逆序放于数组，就比如说位置0和位置n-1的数，因为题目条件，他们俩之间一定有一个最大的树可以放在新数组的最后面，依次类推） class Solution { public: vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) { int n=nums.size(); vector\u003cint\u003e ans(n); for(int left=0,right=n-1,p=n-1;left\u003c=right;) { if(nums[left]*nums[left]\u003cnums[right]*nums[right]) { ans[p]=nums[right]*nums[right]; right--; } else { ans[p]=nums[left]*nums[left]; left++; } p--; } return ans; } }; ","date":"2022-01-26","objectID":"/algorithm_day1/:0:3","tags":["Cpp","sort"],"title":"【LeetCode】有序数组的平方","uri":"/algorithm_day1/"}]